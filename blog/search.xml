<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VPS Notes]]></title>
    <url>%2F2017%2F08%2F27%2FVPS%20Notes%2F</url>
    <content type="text"><![CDATA[个人VPS折腾笔记(Based on Center OS 7)近期搬瓦工上线了CN2线路的VPS,售价$29.9，还不错，便入手了一台。购买链接(含aff) 加速（锐速,BBR）锐速安装wget1yum install wget 下载锐速脚本1wget -N --no-check-certificate https://raw.githubusercontent.com/wn789/serverspeeder/master/serverspeeder.sh 执行脚本1bash serverspeeder.sh 默认脚本不支持Center OS,需要更换内核（版本：3.10.0-327.el7.x86_64） 1rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-3.10.0-229.1.2.el7.x86_64.rpm --force 查看安装好的内核 1rpm -qa | grep kernel 存在kernel-3.10.0-327.el7.x86_64即可 重启VPS 12rebootuname -a //查看是否更换成功 内核如下 1Linux host.localdomain 3.10.0-229.1.2.el7.x86_64 #1 SMP Fri Mar 27 03:04:26 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux 再次执行脚本 1bash serverspeeder.sh BBR安装wget1yum install wget 下载bbr脚本并执行123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 查看安装情况12345678uname -rsysctl net.ipv4.tcp_available_congestion_control //查看返回值返回net.ipv4.tcp_available_congestion_control = bbr cubic reno即正常sysctl net.ipv4.tcp_congestion_control返回 net.ipv4.tcp_congestion_control = bbrlsmod | grep bbr //查看bbr是否启动 使用一键脚本1wget -N --no-check-certificate "https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh" &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh 防火墙centerOS 7默认为firewalld防火墙使用方法 firewalld的基本使用启动: systemctl start firewalld 查看状态: systemctl status firewalld 停止： systemctl disable firewalld 禁用： systemctl stop firewalld systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。启动一个服务：systemctl start firewalld.service 关闭一个服务：systemctl stop firewalld.service 重启一个服务：systemctl restart firewalld.service 显示一个服务的状态：systemctl status firewalld.service 在开机时启用一个服务：systemctl enable firewalld.service 在开机时禁用一个服务：systemctl disable firewalld.service 查看服务是否开机启动：systemctl is-enabled firewalld.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled 查看启动失败的服务列表：systemctl --failed 配置firewalld-cmd查看版本： firewall-cmd --version 查看帮助： firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口： firewall-cmd --zone=public --list-ports 更新防火墙规则： firewall-cmd --reload 查看区域信息: firewall-cmd --get-active-zones 查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态： firewall-cmd --panic-off 查看是否拒绝： firewall-cmd --query-panic 那怎么开启一个端口呢 添加12firewall-cmd --zone=public --add-port=80/tcp --permanent(--permanent永久生效，没有此参数重启后失效) 重新载入 firewall-cmd --reload 查看firewall-cmd --zone= public --query-port=80/tcp 删除 firewall-cmd --zone= public --remove-port=80/tcp --permanent 搭建Hexo博客环境搭建安装node安装编译环境1sudo yum install gcc gcc-c++ 安装nvm12curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.1/install.sh | bashnvm --version //查看安装的nvm版本 选择版本并安装123nvm list-remote //查看所有node版本nvm install v6.11.2 //安装v6.11.2node --version //查看安装的node版本 安装git1yum install git-core 安装hexo12npm install hexo-cli -ghexo --version 更新OpenSSL123456789101112wget https://github.com/openssl/openssl/archive/OpenSSL_1_1_1b.zipunzip OpenSSL_1_1_1b.zipcd openssl-OpenSSL_1_1_1bcurl https://raw.githubusercontent.com/hakasenyang/openssl-patch/master/openssl-1.1.1b-chacha_draft.patch | patch -p1./configmake install执行 openssl version 必报错误openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory解决方法ln -s /usr/local/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1ln -s /usr/local/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1 安装nginx(默认配置)12345678910wget http://nginx.org/download/nginx-1.15.10.tar.gztar -zxvf nginx-1.15.10.tar.gzcd nginx-1.15.10./configure --with-http_v2_module --with-http_ssl_module --with-http_gzip_static_moduleyum install -y pcre-develyum install -y zlib-develmakemake install 开机启动nginx即在rc.local增加启动代码就可以了。1234vi /etc/rc.local增加一行 /usr/local/nginx/sbin/nginx设置执行权限：chmod 755 rc.local 启用服务器生成网页执行以下命令生成public文件夹即为博客网页12hexo cleanhexo generate 修改nginx.conf修改server下location-root,该目录为网站对应的目录,将上面生成的目录下所有文件拷贝到上述目录，执行/usr/local/nginx/sbin/nginx -s reload重启nginx即可 nginx.conf(仅修改部分)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455user nginx;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name xxx.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /home/nginx/www/blog; index index.html index.htm; &#125; error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 启用HTTPS(TLS1.3)nginx环境见环境安装 SSL证书（通配证书）使用acme.sh 1curl https://get.acme.sh | sh 采用子账号生成Ali_Key 和 Ali_Secret 12export Ali_Key=""export Ali_Secret="" 生成证书1acme.sh --issue --dns dns_ali -d mxdhqm.com -d *.mxdhqm.com 自动续期证书由于 Let’s Encrypt 默认有效期为90天，过了60天就可以续期。为了避免忘记续期，添加一个脚本每天自动运行。为了保证nginx稳定性，每天定期重启一次，一并添加至脚本中 ssl_renew.sh123#!/bin/shacme.sh --renew -d mxdhqm.com -d *.mxdhqm.comnginx -s reload 定期执行脚本修改/etc/crontab，添加执行命令 10 5 * * * root sh /root/ssl_renew.sh &gt; /dev/null 2&gt;&amp;1 查看是否添加成功 crontab -l 修改nginx.conf要想全站https，添加301跳转 12345678server&#123; listen 80; server_name xxx.com; //跳转域名 #告诉浏览器有效期内只准用 https 访问 add_header Strict-Transport-Security max-age=63072000; #永久重定向到 https 站点 return 301 https://$server_name$request_uri; &#125; https server，默认监听443端口ssl_protocols 中加入 TLSv1.3 (仅 Nginx 1.13.0 及以上 低版本用 TLSv1.2就行) ssl_ciphers 加入 TLS1.3 加密套件 支持的有如下 12345TLS13-AES-256-GCM-SHA384TLS13-CHACHA20-POLY1305-SHA256TLS13-AES-128-GCM-SHA256TLS13-AES-128-CCM-8-SHA256TLS13-AES-128-CCM-SHA256 nginx.conf部分配置如下1234567891011121314151617181920212223server &#123; listen 443 ssl; server_name xxx.com; #证书路径 ssl_certificate /root/.acme.sh/mxdhqm.com/fullchain.cer; ssl_certificate_key /root/.acme.sh/mxdhqm.com/mxdhqm.com.key; ssl_trusted_certificate /root/.acme.sh/mxdhqm.com/ca.cer; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers 'TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256:TLS13-AES-128-CCM-8-SHA256:TLS13-AES-128-CCM-SHA256:EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+ECDSA+AES128:EECDH+aRSA+AES128:EECDH+ECDSA+AES256:EECDH+aRSA+AES256:SSLCipherSuiteECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256;'; ssl_prefer_server_ciphers on; location / &#123; root /home/nginx/www/blog; index index.html index.htm; &#125; &#125; 最终效果]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>VPS Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPod的使用]]></title>
    <url>%2F2016%2F10%2F06%2Fusing%20cocoapod%2F</url>
    <content type="text"><![CDATA[前言macOS Sierra 出来了半个月了吧，电脑iCloud一直有问题没时间弄，十一期间决定重新安装了电脑，由于不想使用Time Machine，故安装完后环境啥的都要重新配置了。。。。。。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPod</tag>
        <tag>using CocoaPod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsPatch]]></title>
    <url>%2F2015%2F12%2F13%2FjsPatch%2F</url>
    <content type="text"><![CDATA[https://mxdhqm.com]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>NSTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSTime小记]]></title>
    <url>%2F2015%2F12%2F13%2FNSTime%2F</url>
    <content type="text"><![CDATA[NSRunLoopCommonModes和Timer 当使用NSTimer的scheduledTimerWithTimeInterval方法时。事实上此时Timer会被加入到当前线程的Run Loop中，且模式是默认的NSDefaultRunLoopMode。而如果当前线程就是主线程，也就是UI线程时，某些UI事件，比如UIScrollView的拖动操作，会将Run Loop切换成NSEventTrackingRunLoopMode模式，在这个过程中，默认的NSDefaultRunLoopMode模式中注册的事件是不会被执行的。也就是说，此时使用scheduledTimerWithTimeInterval添加到Run Loop中的Timer就不会执行。 所以为了设置一个不被UI干扰的Timer，我们需要手动创建一个Timer，然后使用NSRunLoop的addTimer:forMode:方法来把Timer按照指定模式加入到Run Loop中。这里使用的模式是：NSRunLoopCommonModes，这个模式等效于NSDefaultRunLoopMode和NSEventTrackingRunLoopMode的结合。（参考Apple文档） 参考代码： (void)viewDidLoad{ [super viewDidLoad]; NSLog(@”主线程 %@”, [NSThread currentThread]); //创建Timer NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(timer_callback) userInfo:nil repeats:YES]; //使用NSRunLoopCommonModes模式，把timer加入到当前Run Loop中。 [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];} //timer的回调方法 (void)timer_callback{ NSLog(@”Timer %@”, [NSThread currentThread]);} 输出： 主线程 &lt;NSThread: 0x71501e0&gt;{name = (null), num = 1}Timer &lt;NSThread: 0x71501e0&gt;{name = (null), num = 1}Timer &lt;NSThread: 0x71501e0&gt;{name = (null), num = 1}Timer &lt;NSThread: 0x71501e0&gt;{name = (null), num = 1} 返回目录 NSThread和Timer 上面讲的NSRunLoopCommonModes和Timer中有一个问题，这个Timer本质上是在当前线程的Run Loop中循环执行的，因此Timer的回调方法不是在另一个线程的。那么怎样在真正的多线程环境下运行一个Timer呢？ 可以先试试NSThread。同上，我们还是会把Timer加到Run Loop中，只不过这个是在另一个线程中，因此我们需要手动执行Run Loop（通过NSRunLoop的run方法），同时注意在新的线程执行中加入@autoreleasepool。 完整代码如下： (void)viewDidLoad{ [super viewDidLoad]; NSLog(@”主线程 %@”, [NSThread currentThread]); //创建并执行新的线程 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil]; [thread start];} (void)newThread{ @autoreleasepool { //在当前Run Loop中添加timer，模式是默认的NSDefaultRunLoopMode [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(timer_callback) userInfo:nil repeats:YES]; //开始执行新线程的Run Loop [[NSRunLoop currentRunLoop] run]; }} //timer的回调方法 (void)timer_callback{ NSLog(@”Timer %@”, [NSThread currentThread]);} 输出： 主线程 &lt;NSThread: 0x7118800&gt;{name = (null), num = 1}Timer &lt;NSThread: 0x715c2e0&gt;{name = (null), num = 3}Timer &lt;NSThread: 0x715c2e0&gt;{name = (null), num = 3}Timer &lt;NSThread: 0x715c2e0&gt;{name = (null), num = 3} 返回目录 GCD中的Timer GCD中的Timer应该是最灵活的，而且是多线程的。GCD中的Timer是靠Dispatch Source来实现的。 因此先需要声明一个dispatch_source_t本地变量： @interface ViewController (){ dispatch_source_t _timer;} 接着通过dispatch_source_create函数来创建一个专门的Dispatch Source，接着通过dispatch_source_set_timer函数来设置Timer的参数，注意这里的时间参数有些蛋疼。 开始时间的类型是dispatch_time_t，最好用dispatch_time或者dispatch_walltime函数来创建dispatch_time_t对象。如果需要Timer立即执行，可以传入dispatch_time(DISPATCH_TIME_NOW, 0)。 internal和leeway参数分别表示Timer的间隔时间和精度。类型都是uint64_t。间隔时间的单位竟然是纳秒。可以借助预定义的NSEC_PER_SEC宏，比如如果间隔时间是两秒的话，那interval参数就是：2 * NSEC_PER_SEC。 leeway就是精度参数，代表系统可以延时的时间间隔，最高精度当然就传0。 然后通过dispatch_source_set_event_handler函数来设置Dispatch Source的事件回调，这里当然是使用Block了。 最后所有dispatch_source_t创建后默认都是暂停状态的，所以必须通过dispatch_resume函数来开始事件监听。这里就代表着开始Timer。 完整代码： NSLog(@”主线程 %@”, [NSThread currentThread]);//间隔还是2秒uint64_t interval = 2 * NSEC_PER_SEC;//创建一个专门执行timer回调的GCD队列dispatch_queue_t queue = dispatch_queue_create(“my queue”, 0);//创建Timer_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);//使用dispatch_source_set_timer函数设置timer参数dispatch_source_set_timer(_timer, dispatch_time(DISPATCH_TIME_NOW, 0), interval, 0);//设置回调dispatch_source_set_event_handler(_timer, ^(){ NSLog(@”Timer %@”, [NSThread currentThread]);});//dispatch_source默认是Suspended状态，通过dispatch_resume函数开始它dispatch_resume(_timer); 输出： 主线程 &lt;NSThread: 0x711fab0&gt;{name = (null), num = 1}Timer &lt;NSThread: 0x713a380&gt;{name = (null), num = 3}Timer &lt;NSThread: 0x713a380&gt;{name = (null), num = 3}Timer &lt;NSThread: 0x713a380&gt;{name = (null), num = 3}]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>NSTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局包含Image和Title的UIButton]]></title>
    <url>%2F2015%2F12%2F10%2Fcustom%20UIButton%20Title%20%26%20Image%2F</url>
    <content type="text"><![CDATA[UIButton中的titleEdgeInsets和imageEdgeInsets可以管理button中image和title的布局。 如果对其理解不够深入，用纯数字进行布局管理，经过不断的调试，还是能试出来的，但是如果改变了图片大小或文字长度，又要再来一遍。 作为程序猿，我们不应该放弃任何一个偷懒的机会。 默认情况下，是图片在左，文字在右，垂直居中显示，如下图： 12button.titleEdgeInsets = UIEdgeInsetsZero;button.imageEdgeInsets = UIEdgeInsetsZero; 设置如下布局后，图片和文字都居中显示。 1234button.titleEdgeInsets = UIEdgeInsetsMake(0, -button.imageView.frame.size.width, 0, 0);// button.imageEdgeInsets = UIEdgeInsetsMake(0, 0, 0, -button.titleLabel.frame.size.width); // 由于iOS8中titleLabel的size为0，用上面这样设置有问题，修改一下即可button.imageEdgeInsets = UIEdgeInsetsMake(0, 0, 0, -button.titleLabel.intrinsicContentSize.width); 如果想图片在上，文字在下，水平居中显示，则按下面设置即可： 1234button.titleEdgeInsets = UIEdgeInsetsMake(0, -button.imageView.frame.size.width, -button.imageView.frame.size.height, 0);// button.imageEdgeInsets = UIEdgeInsetsMake(-button.titleLabel.frame.size.height, 0, 0, -button.titleLabel.frame.size.width);// 由于iOS8中titleLabel的size为0，用上面这样设置有问题，修改一下即可button.imageEdgeInsets = UIEdgeInsetsMake(-button.titleLabel.intrinsicContentSize.height, 0, 0, -button.titleLabel.intrinsicContentSize.width); 如果觉得图片和文字离的太近了，稍微分开一点： 12345CGFloat offset = 40.0f;button.titleEdgeInsets = UIEdgeInsetsMake(0, -button.imageView.frame.size.width, -button.imageView.frame.size.height-offset/2, 0);// button.imageEdgeInsets = UIEdgeInsetsMake(-button.titleLabel.frame.size.height-offset/2, 0, 0, -button.titleLabel.frame.size.width);// 由于iOS8中titleLabel的size为0，用上面这样设置有问题，修改一下即可button.imageEdgeInsets = UIEdgeInsetsMake(-button.titleLabel.intrinsicContentSize.height-offset/2, 0, 0, -button.titleLabel.intrinsicContentSize.width); 文字左对齐，图片右对齐 12button.titleEdgeInsets = UIEdgeInsetsMake(0, -button.imageView.frame.size.width - button.frame.size.width + button.titleLabel.intrinsicContentSize.width, 0, 0); button.imageEdgeInsets = UIEdgeInsetsMake(0, 0, 0, -button.titleLabel.frame.size.width - button.frame.size.width + button.imageView.frame.size.width);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UIButton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客(三)]]></title>
    <url>%2F2015%2F12%2F07%2FBuild%20personal%20blog%20three%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客(二)]]></title>
    <url>%2F2015%2F12%2F06%2FBuild%20personal%20blog%20two%2F</url>
    <content type="text"><![CDATA[搭建WordPress Blog ##本地安装wordpress ###准备]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客(一)]]></title>
    <url>%2F2015%2F12%2F05%2FBuild%20personal%20blog%20one%2F</url>
    <content type="text"><![CDATA[此处记录从笔记到博客一步步的转化的过程 ##传统笔记当完成一件事过后，需要记录下来苏发现的问题，笔记便成了最好的选择，从以前的纸质笔记开始，一段时间过后，发现再次遇到某一问题时，无法准确定位到自己笔记的位置所在，故寻求新的方案。 ##在线笔记尝试在电脑上记录笔记，但使用word或记事本的话无法方便管理(当然存在本地很好的记录软件)，为了方便在不同终端上都可以方便记录和预览笔记，当时我选择了印象笔记。 ##在线博客之后选择了CSDN，51CTO等等第三方的博客服务，始终感觉限制很多(省略N字)，于是便开始尝试走向了自己搭建博客的道路。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关闭Android File Transfer自启]]></title>
    <url>%2F2015%2F07%2F13%2Fremove%20Android%20File%20Transfer%2F</url>
    <content type="text"><![CDATA[在Mac中查看安卓手机数据要用到Android File Transfer这个软件，但是一直删不掉自启，使用CleanMyMac删除后，再次启动任然能自启，使用以下方法达到屏蔽自启1.在活动监视器中结束Android File Transfer进程2.在系统偏好设置-用户和群组中，点击登陆项，把Android File Transfer的启动项删除3.在Terminal中依次运行如下命令 123rm -r ~/Library/Application\ Support/Google/Android\ File\ Transfer/Android\ File\ Transfer\ Agent.appcd /Applications/Android\ File\ Transfer.app/Contents/Resourcesmv Android\ File\ Transfer\ Agent.app Android\ File\ Transfer\ Agent.app.disable]]></content>
      <categories>
        <category>Mac日常</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Android File Transfer</tag>
      </tags>
  </entry>
</search>
